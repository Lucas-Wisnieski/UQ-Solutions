<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>AI Program Summary</title>
    <style>
        body {
            font-family: 'Avenir', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 1px solid #e9ecef;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 2px solid #dee2e6;
        }
        
        .title {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
            margin: 0;
        }
        
        .refresh-btn {
            background: #03304d;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-family: 'Avenir', sans-serif;
            transition: all 0.3s ease;
        }
        
        .refresh-btn:hover {
            background: #024a73;
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(3, 48, 77, 0.4);
        }
        
        .loading {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 20px;
            background: #e3f2fd;
            border-radius: 8px;
            color: #1976d2;
            font-weight: 500;
            font-family: 'Avenir', sans-serif;
            border: 1px solid #bbdefb;
        }
        
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #e3f2fd;
            border-top: 2px solid #1976d2;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .summary-text {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 12px;
            padding: 24px;
            min-height: 200px;
            font-size: 16px;
            line-height: 1.6;
            color: #2c3e50;
            white-space: pre-wrap;
            font-family: 'Avenir', sans-serif;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
        }
        
        .error {
            background: #ffebee;
            color: #c62828;
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #ffcdd2;
            margin-top: 20px;
            font-family: 'Avenir', sans-serif;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">AI Program Summary</h1>
            <div>
                <button id="diagnosticsBtn" style="margin-right: 10px; padding: 8px 16px; background: #32a900; color: white; border: none; border-radius: 4px; cursor: pointer; font-family: 'Avenir', sans-serif; font-weight: 500;">
                    Run Diagnostics
                </button>
                <button class="refresh-btn" id="refreshBtn">
                    Generate Summary
                </button>
            </div>
        </div>
        
        <div id="loadingIndicator" class="loading" style="display: none;">
            <div class="spinner"></div>
            <span>Analyzing program data...</span>
        </div>
        
        <div class="summary-container">
            <div class="summary-text" id="summaryText">
                Click "Generate Summary" to analyze your program data and create an AI-powered summary.
            </div>
        </div>
        
        <div id="errorMessage" class="error" style="display: none;"></div>
    </div>

    <script>
        console.log('üöÄ AI Summary Extension v2025.01.25.3 loaded');
        
        // GitHub Pages URLs for Tableau API
        const GITHUB_API_URLS = [
            'https://lucas-wisnieski.github.io/UQ-Solutions/js/tableau.extensions.1.latest.js',
            'https://lucas-wisnieski.github.io/UQ-Solutions/js/tableau.extensions.1.latest.min.js'
        ];

        // Custom prompt URL
        const CUSTOM_PROMPT_URL = 'https://raw.githubusercontent.com/Lucas-Wisnieski/UQ-Solutions/main/prompts/ai-analysis-prompt.txt';

        // Global state
        let isProcessing = false;
        let customPrompt = null; // Cache for the custom prompt

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, setting up...');
            
            try {
                document.getElementById('diagnosticsBtn').addEventListener('click', runDiagnostics);
                document.getElementById('refreshBtn').addEventListener('click', generateSummary);
                console.log('‚úÖ Event listeners added');
                
                // Load custom prompt first, then Tableau API
                loadCustomPrompt();
            } catch (error) {
                console.error('Setup error:', error);
                showError('Extension setup failed: ' + error.message);
            }
        });

        function loadCustomPrompt() {
            console.log('üîç Loading custom prompt from GitHub...');
            
            fetch(CUSTOM_PROMPT_URL)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Prompt file not found: ' + response.status);
                    }
                    return response.text();
                })
                .then(function(promptText) {
                    customPrompt = promptText.trim();
                    console.log('‚úÖ Custom prompt loaded successfully');
                    console.log('üìÑ Prompt length:', customPrompt.length, 'characters');
                    
                    // Now load Tableau API
                    loadTableauAPI();
                })
                .catch(function(error) {
                    console.error('‚ùå Failed to load custom prompt:', error);
                    showError('Failed to load analysis prompt: ' + error.message + '\n\nPlease ensure the prompt file exists at:\n' + CUSTOM_PROMPT_URL);
                });
        }

        function loadTableauAPI() {
            console.log('üîç Loading Tableau API...');
            
            // Check if already available
            if (typeof tableau !== 'undefined' && tableau.extensions) {
                console.log('‚úÖ Tableau API already available');
                initializeExtension();
                return;
            }

            const urls = [
                ...GITHUB_API_URLS,
                'https://raw.githubusercontent.com/tableau/extensions-api/master/lib/tableau.extensions.1.latest.js'
            ];

            let currentIndex = 0;

            function tryLoad() {
                if (currentIndex >= urls.length) {
                    console.log('‚ùå All API loading attempts failed');
                    return;
                }

                const url = urls[currentIndex];
                console.log(`üîÑ Trying: ${url}`);

                const script = document.createElement('script');
                script.src = url;
                
                script.onload = function() {
                    console.log(`‚úÖ Loaded from: ${url}`);
                    if (typeof tableau !== 'undefined' && tableau.extensions) {
                        initializeExtension();
                    }
                };
                
                script.onerror = function() {
                    console.log(`‚ùå Failed: ${url}`);
                    currentIndex++;
                    setTimeout(tryLoad, 100);
                };
                
                document.head.appendChild(script);
            }

            tryLoad();
        }

        function initializeExtension() {
            if (tableau && tableau.extensions) {
                tableau.extensions.initializeAsync()
                    .then(function() {
                        console.log('üéâ Extension initialized!');
                    })
                    .catch(function(error) {
                        console.error('‚ùå Init failed:', error);
                    });
            }
        }

        function runDiagnostics() {
            if (isProcessing) return;
            
            console.log('=== DIAGNOSTICS ===');
            
            let report = 'üîç DIAGNOSTIC REPORT\n\n';
            
            // Check API
            if (typeof tableau !== 'undefined' && tableau.extensions) {
                report += 'üìä TABLEAU API: ‚úÖ Available\n';
                
                try {
                    const worksheets = tableau.extensions.dashboardContent.dashboard.worksheets;
                    report += `üìã WORKSHEETS: ${worksheets.length} found\n`;
                    
                    worksheets.forEach((ws, i) => {
                        report += `  ${i + 1}. "${ws.name}"\n`;
                    });
                    
                    const target = worksheets.find(ws => 
                        ws.name.toLowerCase().includes('claude') || 
                        ws.name.toLowerCase().includes('metrics')
                    );
                    
                    if (target) {
                        report += `\nüéØ TARGET: "${target.name}" ‚úÖ\n`;
                    } else {
                        report += '\n‚ö†Ô∏è No target worksheet found\n';
                    }
                    
                } catch (error) {
                    report += `üìä API ERROR: ${error.message}\n`;
                }
            } else {
                report += 'üìä TABLEAU API: ‚ùå Not Available\n';
            }
            
            report += '\nüîß PROXY: https://uq-solutions.vercel.app/api/claude ‚úÖ\n';
            report += `\nüìÑ CUSTOM PROMPT: ${customPrompt ? '‚úÖ Loaded (' + customPrompt.length + ' chars)' : '‚ùå Not loaded'}\n`;
            report += '\nüéØ STATUS: Ready for testing';
            
            document.getElementById('summaryText').textContent = report;
        }

        function generateSummary() {
            if (isProcessing) {
                console.log('Already processing...');
                return;
            }
            
            // Check if custom prompt is loaded
            if (!customPrompt) {
                showError('Custom prompt not loaded. Please refresh the page and try again.');
                return;
            }
            
            isProcessing = true;
            console.log('üöÄ Starting summary generation with custom prompt...');
            
            document.getElementById('loadingIndicator').style.display = 'block';
            hideError();
            
            // Simple timeout
            setTimeout(function() {
                if (isProcessing) {
                    isProcessing = false;
                    document.getElementById('loadingIndicator').style.display = 'none';
                    showError('Process timed out after 45 seconds');
                }
            }, 45000);
            
            extractData()
                .then(function(data) {
                    console.log('‚úÖ Data extracted:', data);
                    
                    // Only proceed if we have meaningful metrics
                    if (!data.metrics || data.metrics.length === 0) {
                        throw new Error('No meaningful metrics extracted from the data');
                    }
                    
                    return callAPI(data);
                })
                .then(function(summary) {
                    document.getElementById('summaryText').innerHTML = summary;
                })
                .catch(function(error) {
                    console.error('‚ùå Failed:', error);
                    showError('Failed: ' + error.message);
                })
                .finally(function() {
                    isProcessing = false;
                    document.getElementById('loadingIndicator').style.display = 'none';
                });
        }

        function extractData() {
            return new Promise(function(resolve, reject) {
                // Check API availability
                if (typeof tableau === 'undefined' || !tableau.extensions) {
                    reject(new Error('Tableau API not available'));
                    return;
                }

                try {
                    const worksheets = tableau.extensions.dashboardContent.dashboard.worksheets;
                    console.log(`Found ${worksheets.length} worksheets`);
                    
                    // Find target worksheet
                    let target = worksheets.find(ws => 
                        ws.name.toLowerCase().includes('claude') || 
                        ws.name.toLowerCase().includes('metrics')
                    );
                    
                    if (!target && worksheets.length > 0) {
                        target = worksheets[0];
                    }
                    
                    if (!target) {
                        reject(new Error('No worksheets found'));
                        return;
                    }
                    
                    console.log(`Using worksheet: "${target.name}"`);
                    
                    // Force refresh the worksheet data before extracting
                    console.log('üîÑ Refreshing worksheet data...');
                    
                    // Try to refresh the data first, then extract
                    Promise.resolve()
                        .then(function() {
                            // Try to refresh if the method exists
                            if (target.refreshDataAsync) {
                                console.log('Attempting data refresh...');
                                return target.refreshDataAsync();
                            } else {
                                console.log('Refresh not available, proceeding with current data...');
                                return Promise.resolve();
                            }
                        })
                        .catch(function(refreshError) {
                            console.log('Refresh failed, proceeding with current data:', refreshError.message);
                            return Promise.resolve(); // Continue even if refresh fails
                        })
                        .then(function() {
                            // Small delay to ensure data is updated
                            return new Promise(resolve => setTimeout(resolve, 500));
                        })
                        .then(function() {
                            // Now try to get the updated summary data
                            return target.getSummaryDataAsync();
                        })
                        .then(function(summaryData) {
                            console.log(`Got ${summaryData.data.length} summary rows`);
                            
                            if (summaryData.data.length > 0) {
                                const data = processSummaryData(summaryData);
                                if (data.metrics.length >= 3) {
                                    console.log('‚úÖ Using summary data with', data.metrics.length, 'metrics');
                                    resolve(data);
                                    return;
                                } else {
                                    console.log(`‚ö†Ô∏è Summary data has only ${data.metrics.length} metrics, trying underlying data...`);
                                }
                            }
                            
                            // Fallback to underlying data only if summary failed
                            console.log('Summary data insufficient, trying underlying data...');
                            return target.getUnderlyingDataAsync();
                        })
                        .then(function(underlyingData) {
                            if (!underlyingData) {
                                reject(new Error('No underlying data available'));
                                return;
                            }
                            
                            console.log(`Got ${underlyingData.data.length} underlying rows`);
                            const data = processUnderlyingData(underlyingData);
                            
                            if (data.metrics.length === 0) {
                                reject(new Error('No meaningful metrics found in underlying data'));
                                return;
                            }
                            
                            console.log('‚úÖ Using underlying data with', data.metrics.length, 'metrics');
                            resolve(data);
                        })
                        .catch(function(error) {
                            console.error('Data extraction error:', error);
                            reject(new Error('Data extraction failed: ' + error.message));
                        });
                    
                } catch (error) {
                    reject(error);
                }
            });
        }

        function processSummaryData(dataTable) {
            const columns = dataTable.columns.map(col => col.fieldName);
            const rows = dataTable.data;
            
            console.log('Summary columns:', columns);
            console.log('Summary rows:', rows.length);
            
            // Debug: Show first few rows
            console.log('First 3 rows:', rows.slice(0, 3));
            
            const metrics = [];
            
            // Look for the "Measure Values" column which contains the actual scores
            const measureValuesIndex = columns.findIndex(col => 
                col.toLowerCase().includes('measure values') || 
                col.toLowerCase().includes('values')
            );
            
            const measureNamesIndex = columns.findIndex(col => 
                col.toLowerCase().includes('measure names') || 
                col.toLowerCase().includes('names')
            );
            
            console.log('Measure Values column index:', measureValuesIndex);
            console.log('Measure Names column index:', measureNamesIndex);
            
            // Define the aggregated score metrics we want (matching your table columns)
            const targetScoreMetrics = [
                'Total Score', 'Market Growth Score', 'Schools Like Us Score', 'Opportunity Size Score',
                'Workforce Demand Score', 'Earning Outcomes Score', 'S.U.G., Geog. Mkt.',
                '% Insts Growing, Geog. Mkt.', 'S.U.G., Seg. Mkt.', '% Growing, Seg. Mkt.',
                '# Insts. with Pgm., Seg. Mkt.', '% Insts. with Pgm., Seg. Mkt.',
                '% Growing, Add\'l Ref. Mkt.', 'Market Concentration, Largest Two Programs, Geog. Mkt.',
                'Expected Completions per Year', 'Median Compl\'s/Yr., Seg. Mkt.',
                'Relative Interquartile Ratio', 'Program Size Consistency Index',
                'ACS Salary, State', 'BLS Salary, State', '1st-Year Earnings, Geog. Mkt, Adjusted',
                '1st-Year Earnings, Seg. Mkt., Adjusted', '% Online, Geog. Mkt.', '% Online, Seg. Mkt.',
                'Job Postings Index, State', 'Jobs SUG, State', 'Workforce Demand:Supply Ratio, State',
                'Ann. Unit Growth, Jobs, State', 'Ann. % Growth, Jobs, State'
            ];
            
            if (measureValuesIndex >= 0 && measureNamesIndex >= 0) {
                console.log('‚úÖ Found Measure Names/Values columns - extracting aggregated score metrics...');
                
                // First, let's see what measure names are actually available
                const availableMeasureNames = new Set();
                rows.forEach(function(row) {
                    if (row[measureNamesIndex]) {
                        const nameCell = row[measureNamesIndex];
                        const measureName = (typeof nameCell === 'object' && nameCell.value !== undefined) 
                            ? nameCell.value : nameCell;
                        if (measureName) {
                            availableMeasureNames.add(measureName);
                        }
                    }
                });
                
                console.log('üìã Available measure names in data:', Array.from(availableMeasureNames));
                
                // Process each row to extract the aggregated score metrics
                rows.forEach(function(row, rowIndex) {
                    let measureName = null;
                    let measureValue = null;
                    
                    // Extract measure name
                    if (row[measureNamesIndex]) {
                        const nameCell = row[measureNamesIndex];
                        measureName = (typeof nameCell === 'object' && nameCell.value !== undefined) 
                            ? nameCell.value : nameCell;
                    }
                    
                    // Extract measure value
                    if (row[measureValuesIndex]) {
                        const valueCell = row[measureValuesIndex];
                        measureValue = (typeof valueCell === 'object' && valueCell.value !== undefined) 
                            ? valueCell.value : valueCell;
                    }
                    
                    // If we have both name and numeric value, include it (no filtering for now)
                    if (measureName && typeof measureValue === 'number') {
                        // Clean up the measure name for better readability
                        let cleanName = measureName;
                        
                        // Remove Tableau's internal field references
                        if (typeof cleanName === 'string') {
                            // Extract the actual measure name from Tableau's internal format
                            const nameMatch = cleanName.match(/\[usr:([^\]]+)\]/);
                            if (nameMatch) {
                                cleanName = nameMatch[1]
                                    .replace(/_\d+:/g, '') // Remove ID numbers and colons
                                    .replace(/qk\]?$/, '') // Remove 'qk' suffix
                                    .replace(/\s+\(copy[^)]*\)/gi, '') // Remove "(copy)" variations
                                    .replace(/[_]/g, ' ') // Replace underscores with spaces
                                    .trim();
                            }
                            
                            // If no match, try to clean the original name
                            if (!nameMatch) {
                                cleanName = cleanName
                                    .replace(/\[federated[^\]]+\]\./g, '') // Remove federated prefix
                                    .replace(/\[usr:/g, '') // Remove usr: prefix
                                    .replace(/\]/g, '') // Remove brackets
                                    .replace(/_\d+:/g, '') // Remove ID numbers
                                    .replace(/qk$/, '') // Remove qk suffix
                                    .replace(/\s+\(copy[^)]*\)/gi, '') // Remove copy variations
                                    .replace(/[_]/g, ' ') // Replace underscores with spaces
                                    .trim();
                            }
                        }
                        
                        // Include metric if it's not a duplicate and seems relevant
                        if (!metrics.some(m => m.name === cleanName)) {
                            // Filter out obviously irrelevant metrics
                            const isRelevant = !cleanName.toLowerCase().includes('calculation') &&
                                             !cleanName.toLowerCase().includes('job index selected institution state') &&
                                             !cleanName.toLowerCase().includes('institution count secondary marketqk') &&
                                             !cleanName.toLowerCase().includes('[sum:institution count');
                            
                            if (isRelevant) {
                                console.log(`‚úÖ Found RELEVANT METRIC: ${cleanName} = ${measureValue}`);
                                
                                metrics.push({
                                    name: cleanName,
                                    value: measureValue,
                                    originalName: measureName // Keep original for debugging
                                });
                            } else {
                                console.log(`‚ö†Ô∏è Skipping irrelevant metric: ${cleanName}`);
                            }
                        }
                    }
                });
            } else {
                console.log('‚ö†Ô∏è Measure Names/Values columns not found, trying alternative approach...');
                
                // Fallback: look for score columns directly
                rows.forEach(function(row, rowIndex) {
                    if (rowIndex < 10) {
                        columns.forEach(function(col, colIndex) {
                            if (row[colIndex]) {
                                let value = row[colIndex];
                                
                                // Extract value from DataValue objects
                                if (typeof value === 'object' && value.value !== undefined) {
                                    value = value.value;
                                }
                                
                                // Check if it's a target score metric
                                if (typeof value === 'number') {
                                    const isTargetMetric = targetScoreMetrics.some(target => 
                                        col.toLowerCase().includes(target.toLowerCase()) ||
                                        target.toLowerCase().includes(col.toLowerCase())
                                    );
                                    
                                    if (isTargetMetric && !metrics.some(m => m.name === col)) {
                                        console.log(`‚úÖ Found direct TARGET SCORE: ${col} = ${value}`);
                                        metrics.push({
                                            name: col,
                                            value: value
                                        });
                                    }
                                }
                            }
                        });
                    }
                });
            }
            
            console.log(`Summary data processing complete: ${metrics.length} metrics found`);
            
            // Extract current program and job from the first row of data
            let currentProgram = '11.0701 | Computer Science | Bachelor\'s'; // default
            let currentJob = 'Software Developers'; // default
            
            if (rows.length > 0) {
                // Check first row for actual current selections
                const firstRow = rows[0];
                
                // Extract CIP Code & Award Level
                if (firstRow[0]) {
                    const cipValue = (typeof firstRow[0] === 'object' && firstRow[0].value !== undefined) 
                        ? firstRow[0].value : firstRow[0];
                    if (cipValue && cipValue !== '%null%') {
                        currentProgram = cipValue;
                        console.log('üìä Current program from data:', currentProgram);
                    }
                }
                
                // Extract UQ Job
                if (firstRow[1]) {
                    const jobValue = (typeof firstRow[1] === 'object' && firstRow[1].value !== undefined) 
                        ? firstRow[1].value : firstRow[1];
                    if (jobValue && jobValue !== '%null%') {
                        currentJob = jobValue;
                        console.log('üéØ Current job from data:', currentJob);
                    }
                }
            }
            
            return {
                program: currentProgram,
                jobTarget: currentJob,
                metrics: metrics,
                dataSource: 'Summary Data (Tableau View)',
                recordCount: rows.length,
                timestamp: new Date().toLocaleString()
            };
        }

        function processUnderlyingData(dataTable) {
            const columns = dataTable.columns.map(col => col.fieldName);
            const rows = dataTable.data;
            
            console.log('Underlying columns count:', columns.length);
            console.log('Underlying rows count:', rows.length);
            
            const metrics = [];
            
            // Define the same aggregated score metrics 
            const targetScoreMetrics = [
                'Total Score', 'Market Growth Score', 'Schools Like Us Score', 'Opportunity Size Score',
                'Workforce Demand Score', 'Earning Outcomes Score', 'S.U.G., Geog. Mkt.',
                '% Insts Growing, Geog. Mkt.', 'S.U.G., Seg. Mkt.', '% Growing, Seg. Mkt.',
                '# Insts. with Pgm., Seg. Mkt.', '% Insts. with Pgm., Seg. Mkt.',
                '% Growing, Add\'l Ref. Mkt.', 'Market Concentration, Largest Two Programs, Geog. Mkt.',
                'Expected Completions per Year', 'Median Compl\'s/Yr., Seg. Mkt.',
                'Relative Interquartile Ratio', 'Program Size Consistency Index',
                'ACS Salary, State', 'BLS Salary, State', '1st-Year Earnings, Geog. Mkt, Adjusted',
                '1st-Year Earnings, Seg. Mkt., Adjusted', '% Online, Geog. Mkt.', '% Online, Seg. Mkt.',
                'Job Postings Index, State', 'Jobs SUG, State', 'Workforce Demand:Supply Ratio, State',
                'Ann. Unit Growth, Jobs, State', 'Ann. % Growth, Jobs, State'
            ];
            
            // Process first few rows to extract target score metrics only
            for (let i = 0; i < Math.min(rows.length, 10); i++) {
                const row = rows[i];
                
                columns.forEach(function(col, colIndex) {
                    if (row[colIndex]) {
                        let value = row[colIndex];
                        
                        // Extract from DataValue
                        if (typeof value === 'object' && value.value !== undefined) {
                            value = value.value;
                        }
                        
                        // Look for target score metrics only
                        if (typeof value === 'number') {
                            const isTarget = targetScoreMetrics.some(target => 
                                col.toLowerCase().includes(target.toLowerCase()) ||
                                target.toLowerCase().includes(col.toLowerCase()) ||
                                col.toLowerCase().replace(/[^a-z0-9]/g, '').includes(target.toLowerCase().replace(/[^a-z0-9]/g, ''))
                            );
                            
                            if (isTarget && !metrics.some(m => m.name === col)) {
                                console.log(`‚úÖ Found TARGET SCORE in underlying: ${col} = ${value}`);
                                metrics.push({
                                    name: col,
                                    value: value
                                });
                            }
                        }
                    }
                });
            }
            
            return {
                program: '11.0701 | Computer Science | Bachelor\'s',
                jobTarget: 'Software Developers',
                metrics: metrics,
                dataSource: 'Underlying Data',
                recordCount: Math.min(rows.length, 100)
            };
        }

        function callAPI(data) {
            // Build the final prompt
            let prompt;
            
            if (customPrompt) {
                // Use custom prompt and replace placeholders
                console.log('üîç Using custom prompt template');
                
                // Replace placeholders in the custom prompt
                prompt = customPrompt
                    .replace(/\{\{PROGRAM\}\}/g, data.program)
                    .replace(/\{\{JOB_TARGET\}\}/g, data.jobTarget)
                    .replace(/\{\{TIMESTAMP\}\}/g, data.timestamp)
                    .replace(/\{\{DATA_SOURCE\}\}/g, data.dataSource)
                    .replace(/\{\{METRICS\}\}/g, data.metrics.map(m => `‚Ä¢ ${m.name}: ${m.value}`).join('\n'));
                
            } else {
                // Fallback to built-in prompt
                console.log('üîç Using fallback built-in prompt');
                
                prompt = `Analyze this program performance data extracted at ${data.timestamp}:

PROGRAM: ${data.program}
JOB TARGET: ${data.jobTarget}
DATA SOURCE: ${data.dataSource}
EXTRACTION TIME: ${data.timestamp}

KEY METRICS:
${data.metrics.map(m => `‚Ä¢ ${m.name}: ${m.value}`).join('\n')}

Provide a concise analysis with:
1. Overall performance assessment
2. Key strengths and areas for improvement
3. Strategic recommendations

Focus on actionable insights for academic administrators. Start with the program name and current timestamp to confirm this is fresh data.`;
            }

            // ===== SEND TO API =====
            console.log('üöÄ Sending prompt to Claude API...');

            return fetch('https://uq-solutions.vercel.app/api/claude', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt: prompt })
            })
            .then(function(response) {
                console.log('API response status:', response.status);
                if (!response.ok) throw new Error('API error: ' + response.status);
                return response.json();
            })
            .then(function(result) {
                console.log('API result:', result);
                if (result && result.success) {
                    return result.content;
                } else {
                    throw new Error(result?.error || 'API returned error');
                }
            })
            .catch(function(error) {
                console.error('API error:', error);
                throw new Error('Claude API failed: ' + error.message);
            });
        }

        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }
    </script>
</body>
</html>
