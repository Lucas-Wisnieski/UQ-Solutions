<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>AI Program Summary</title>
    <style>
        body {
            font-family: 'Avenir', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 10px;
            background: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 12px;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 1px solid #dee2e6;
        }
        
        .title {
            font-size: 20px;
            font-weight: 700;
            color: #2c3e50;
            margin: 0;
        }
        
        .refresh-btn {
            background: #03304d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-family: 'Avenir', sans-serif;
            transition: all 0.3s ease;
        }
        
        .refresh-btn:hover {
            background: #024a73;
            transform: translateY(-1px);
        }
        
        .loading {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px;
            background: #e3f2fd;
            border-radius: 6px;
            color: #1976d2;
            font-weight: 500;
            font-family: 'Avenir', sans-serif;
            border: 1px solid #bbdefb;
            margin-bottom: 16px;
        }
        
        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #e3f2fd;
            border-top: 2px solid #1976d2;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .summary-text {
            background: white;
            padding: 0;
            min-height: 200px;
            font-size: 14px;
            line-height: 1.5;
            color: #2c3e50;
            white-space: pre-wrap;
            font-family: 'Avenir', sans-serif;
        }
        
        /* Style the AI-generated content headings */
        .summary-text h1,
        .summary-text h2 {
            font-size: 24px;
            font-weight: 700;
            color: #03304D;
            margin: 20px 0 12px 0;
            line-height: 1.2;
        }
        
        .summary-text h3 {
            font-size: 20px;
            font-weight: 700;
            color: #03304D;
            margin: 16px 0 8px 0;
            line-height: 1.2;
        }
        
        /* Program name styling */
        .summary-text p:first-of-type {
            font-size: 24px;
            font-weight: 700;
            color: #03304D;
            margin-bottom: 8px;
        }
        
        .error {
            background: #ffebee;
            color: #c62828;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #ffcdd2;
            margin-top: 16px;
            font-family: 'Avenir', sans-serif;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">AI Program Summary</h1>
            <button class="refresh-btn" id="refreshBtn">
                Generate Summary
            </button>
        </div>
        
        <div id="loadingIndicator" class="loading" style="display: none;">
            <div class="spinner"></div>
            <span>Analyzing program data...</span>
        </div>
        
        <div class="summary-container">
            <div class="summary-text" id="summaryText">
                Click "Generate Summary" to analyze your program data and create an AI-powered summary.
            </div>
        </div>
        
        <div id="errorMessage" class="error" style="display: none;"></div>
    </div>

    <script>
        console.log('üöÄ AI Summary Extension v2025.01.25.3 loaded');
        
        // GitHub Pages URLs for Tableau API
        const GITHUB_API_URLS = [
            'https://lucas-wisnieski.github.io/UQ-Solutions/js/tableau.extensions.1.latest.js',
            'https://lucas-wisnieski.github.io/UQ-Solutions/js/tableau.extensions.1.latest.min.js'
        ];

        // Custom prompt URL
        const CUSTOM_PROMPT_URL = 'https://raw.githubusercontent.com/Lucas-Wisnieski/UQ-Solutions/main/prompts/ai-analysis-prompt.txt';

        // Global state
        let isProcessing = false;
        let customPrompt = null; // Cache for the custom prompt

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, setting up...');
            
            try {
                document.getElementById('refreshBtn').addEventListener('click', generateSummary);
                console.log('‚úÖ Event listeners added');
                
                // Load custom prompt first, then Tableau API
                loadCustomPrompt();
            } catch (error) {
                console.error('Setup error:', error);
                showError('Extension setup failed: ' + error.message);
            }
        });

        function loadCustomPrompt() {
            console.log('üîç Loading custom prompt from GitHub...');
            
            fetch(CUSTOM_PROMPT_URL)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Prompt file not found: ' + response.status);
                    }
                    return response.text();
                })
                .then(function(promptText) {
                    customPrompt = promptText.trim();
                    console.log('‚úÖ Custom prompt loaded successfully');
                    console.log('üìÑ Prompt length:', customPrompt.length, 'characters');
                    
                    // Now load Tableau API
                    loadTableauAPI();
                })
                .catch(function(error) {
                    console.error('‚ùå Failed to load custom prompt:', error);
                    showError('Failed to load analysis prompt: ' + error.message + '\n\nPlease ensure the prompt file exists at:\n' + CUSTOM_PROMPT_URL);
                });
        }

        function loadTableauAPI() {
            console.log('üîç Loading Tableau API...');
            
            // Check if already available
            if (typeof tableau !== 'undefined' && tableau.extensions) {
                console.log('‚úÖ Tableau API already available');
                initializeExtension();
                return;
            }

            const urls = [
                ...GITHUB_API_URLS,
                'https://raw.githubusercontent.com/tableau/extensions-api/master/lib/tableau.extensions.1.latest.js'
            ];

            let currentIndex = 0;

            function tryLoad() {
                if (currentIndex >= urls.length) {
                    console.log('‚ùå All API loading attempts failed');
                    return;
                }

                const url = urls[currentIndex];
                console.log(`üîÑ Trying: ${url}`);

                const script = document.createElement('script');
                script.src = url;
                
                script.onload = function() {
                    console.log(`‚úÖ Loaded from: ${url}`);
                    if (typeof tableau !== 'undefined' && tableau.extensions) {
                        initializeExtension();
                    }
                };
                
                script.onerror = function() {
                    console.log(`‚ùå Failed: ${url}`);
                    currentIndex++;
                    setTimeout(tryLoad, 100);
                };
                
                document.head.appendChild(script);
            }

            tryLoad();
        }

        function initializeExtension() {
            if (tableau && tableau.extensions) {
                tableau.extensions.initializeAsync()
                    .then(function() {
                        console.log('üéâ Extension initialized!');
                    })
                    .catch(function(error) {
                        console.error('‚ùå Init failed:', error);
                    });
            }
        }

        // Remove the runDiagnostics function since we removed the button

        function generateSummary() {
            if (isProcessing) {
                console.log('Already processing...');
                return;
            }
            
            // Check if custom prompt is loaded
            if (!customPrompt) {
                showError('Custom prompt not loaded. Please refresh the page and try again.');
                return;
            }
            
            isProcessing = true;
            console.log('üöÄ Starting summary generation with custom prompt...');
            
            document.getElementById('loadingIndicator').style.display = 'block';
            hideError();
            
            // Simple timeout
            setTimeout(function() {
                if (isProcessing) {
                    isProcessing = false;
                    document.getElementById('loadingIndicator').style.display = 'none';
                    showError('Process timed out after 45 seconds');
                }
            }, 45000);
            
            extractData()
                .then(function(data) {
                    console.log('‚úÖ Data extracted:', data);
                    
                    // Only proceed if we have meaningful metrics
                    if (!data.metrics || data.metrics.length === 0) {
                        throw new Error('No meaningful metrics extracted from the data');
                    }
                    
                    return callAPI(data);
                })
                .then(function(summary) {
                    // Convert markdown-style formatting to HTML
                    let htmlSummary = summary
                        .replace(/\*\*(.*?)\*\*/g, '<h2>$1</h2>') // Convert **text** to <h2>text</h2>
                        .replace(/\*(.*?)\*/g, '<em>$1</em>') // Convert *text* to <em>text</em>
                        .replace(/\n/g, '<br>'); // Convert line breaks to <br>
                    
                    document.getElementById('summaryText').innerHTML = htmlSummary;
                })
                .catch(function(error) {
                    console.error('‚ùå Failed:', error);
                    showError('Failed: ' + error.message);
                })
                .finally(function() {
                    isProcessing = false;
                    document.getElementById('loadingIndicator').style.display = 'none';
                });
        }

        function extractData() {
            return new Promise(function(resolve, reject) {
                // Check API availability
                if (typeof tableau === 'undefined' || !tableau.extensions) {
                    reject(new Error('Tableau API not available'));
                    return;
                }

                try {
                    const worksheets = tableau.extensions.dashboardContent.dashboard.worksheets;
                    console.log(`Found ${worksheets.length} worksheets`);
                    
                    // Find target worksheet
                    let target = worksheets.find(ws => 
                        ws.name.toLowerCase().includes('claude') || 
                        ws.name.toLowerCase().includes('metrics')
                    );
                    
                    if (!target && worksheets.length > 0) {
                        target = worksheets[0];
                    }
                    
                    if (!target) {
                        reject(new Error('No worksheets found'));
                        return;
                    }
                    
                    console.log(`Using worksheet: "${target.name}"`);
                    
                    // Force refresh the worksheet data before extracting
                    console.log('üîÑ Refreshing worksheet data...');
                    
                    // Try to refresh the data first, then extract
                    Promise.resolve()
                        .then(function() {
                            // Try to refresh if the method exists
                            if (target.refreshDataAsync) {
                                console.log('Attempting data refresh...');
                                return target.refreshDataAsync();
                            } else {
                                console.log('Refresh not available, proceeding with current data...');
                                return Promise.resolve();
                            }
                        })
                        .catch(function(refreshError) {
                            console.log('Refresh failed, proceeding with current data:', refreshError.message);
                            return Promise.resolve(); // Continue even if refresh fails
                        })
                        .then(function() {
                            // Small delay to ensure data is updated
                            return new Promise(resolve => setTimeout(resolve, 500));
                        })
                        .then(function() {
                            // Now try to get the updated summary data
                            return target.getSummaryDataAsync();
                        })
                        .then(function(summaryData) {
                            console.log(`Got ${summaryData.data.length} summary rows`);
                            
                            if (summaryData.data.length > 0) {
                                const data = processSummaryData(summaryData);
                                if (data.metrics.length >= 3) {
                                    console.log('‚úÖ Using summary data with', data.metrics.length, 'metrics');
                                    resolve(data);
                                    return;
                                } else {
                                    console.log(`‚ö†Ô∏è Summary data has only ${data.metrics.length} metrics, trying underlying data...`);
                                }
                            }
                            
                            // Fallback to underlying data only if summary failed
                            console.log('Summary data insufficient, trying underlying data...');
                            return target.getUnderlyingDataAsync();
                        })
                        .then(function(underlyingData) {
                            if (!underlyingData) {
                                reject(new Error('No underlying data available'));
                                return;
                            }
                            
                            console.log(`Got ${underlyingData.data.length} underlying rows`);
                            const data = processUnderlyingData(underlyingData);
                            
                            if (data.metrics.length === 0) {
                                reject(new Error('No meaningful metrics found in underlying data'));
                                return;
                            }
                            
                            console.log('‚úÖ Using underlying data with', data.metrics.length, 'metrics');
                            resolve(data);
                        })
                        .catch(function(error) {
                            console.error('Data extraction error:', error);
                            reject(new Error('Data extraction failed: ' + error.message));
                        });
                    
                } catch (error) {
                    reject(error);
                }
            });
        }

        function processSummaryData(dataTable) {
            const columns = dataTable.columns.map(col => col.fieldName);
            const rows = dataTable.data;
            
            console.log('Summary columns:', columns);
            console.log('Summary rows:', rows.length);
            
            // DEBUG: Show first 10 rows completely to understand the structure
            console.log('üîç DEBUG: First 10 rows complete structure:');
            for (let i = 0; i < Math.min(rows.length, 10); i++) {
                const row = rows[i];
                console.log(`Row ${i}:`, {
                    cipCode: row[0],
                    uqJob: row[1], 
                    measureName: row[2],
                    measureValue: row[3]
                });
            }
            
            const metrics = [];
            
            // Look for the "Measure Values" column which contains the actual scores
            const measureValuesIndex = columns.findIndex(col => 
                col.toLowerCase().includes('measure values') || 
                col.toLowerCase().includes('values')
            );
            
            const measureNamesIndex = columns.findIndex(col => 
                col.toLowerCase().includes('measure names') || 
                col.toLowerCase().includes('names')
            );
            
            console.log('Measure Values column index:', measureValuesIndex);
            console.log('Measure Names column index:', measureNamesIndex);
            
            if (measureValuesIndex >= 0 && measureNamesIndex >= 0) {
                console.log('‚úÖ Found Measure Names/Values columns - extracting ALL measure data...');
                
                // Process each row to extract ALL measure name/value pairs
                rows.forEach(function(row, rowIndex) {
                    let measureName = null;
                    let measureValue = null;
                    
                    // Extract measure name using the formatted value (clean name)
                    if (row[measureNamesIndex]) {
                        const nameCell = row[measureNamesIndex];
                        // Use _formattedValue for clean names, fallback to _value
                        measureName = nameCell._formattedValue || nameCell.value || 
                                    (typeof nameCell === 'object' && nameCell.value !== undefined ? nameCell.value : nameCell);
                    }
                    
                    // Extract measure value
                    if (row[measureValuesIndex]) {
                        const valueCell = row[measureValuesIndex];
                        measureValue = valueCell._value || valueCell.value || 
                                     (typeof valueCell === 'object' && valueCell.value !== undefined ? valueCell.value : valueCell);
                    }
                    
                    // If we have both name and numeric value, include it
                    if (measureName && typeof measureValue === 'number') {
                        // Use the clean formatted name directly (no need for complex cleaning)
                        const cleanName = measureName.trim();
                        
                        // Include ALL measures - just avoid duplicates
                        if (!metrics.some(m => m.name === cleanName)) {
                            console.log(`‚úÖ Found measure: ${cleanName} = ${measureValue}`);
                            
                            metrics.push({
                                name: cleanName,
                                value: measureValue,
                                originalName: measureName // Keep original for debugging
                            });
                        }
                    }
                });
            } else {
                console.log('‚ö†Ô∏è Measure Names/Values columns not found, trying alternative approach...');
                
                // Fallback: look for score columns directly
                rows.forEach(function(row, rowIndex) {
                    if (rowIndex < 10) {
                        columns.forEach(function(col, colIndex) {
                            if (row[colIndex]) {
                                let value = row[colIndex];
                                
                                // Extract value from DataValue objects
                                if (typeof value === 'object' && value.value !== undefined) {
                                    value = value.value;
                                }
                                
                                // Check if it's a target score metric
                                if (typeof value === 'number') {
                                    const isTargetMetric = targetScoreMetrics.some(target => 
                                        col.toLowerCase().includes(target.toLowerCase()) ||
                                        target.toLowerCase().includes(col.toLowerCase())
                                    );
                                    
                                    if (isTargetMetric && !metrics.some(m => m.name === col)) {
                                        console.log(`‚úÖ Found direct TARGET SCORE: ${col} = ${value}`);
                                        metrics.push({
                                            name: col,
                                            value: value
                                        });
                                    }
                                }
                            }
                        });
                    }
                });
            }
            
            console.log(`Summary data processing complete: ${metrics.length} metrics found`);
            
            // Extract current program and job from the first row of data
            let currentProgram = '11.0701 | Computer Science | Bachelor\'s'; // default
            let currentJob = 'Software Developers'; // default
            
            if (rows.length > 0) {
                // Check first row for actual current selections
                const firstRow = rows[0];
                
                // Extract CIP Code & Award Level
                if (firstRow[0]) {
                    const cipValue = (typeof firstRow[0] === 'object' && firstRow[0].value !== undefined) 
                        ? firstRow[0].value : firstRow[0];
                    if (cipValue && cipValue !== '%null%') {
                        currentProgram = cipValue;
                        console.log('üìä Current program from data:', currentProgram);
                    }
                }
                
                // Extract UQ Job
                if (firstRow[1]) {
                    const jobValue = (typeof firstRow[1] === 'object' && firstRow[1].value !== undefined) 
                        ? firstRow[1].value : firstRow[1];
                    if (jobValue && jobValue !== '%null%') {
                        currentJob = jobValue;
                        console.log('üéØ Current job from data:', currentJob);
                    }
                }
            }
            
            return {
                program: currentProgram,
                jobTarget: currentJob,
                metrics: metrics,
                dataSource: 'Summary Data (Tableau View)',
                recordCount: rows.length,
                timestamp: new Date().toLocaleString()
            };
        }

        function processUnderlyingData(dataTable) {
            const columns = dataTable.columns.map(col => col.fieldName);
            const rows = dataTable.data;
            
            console.log('Underlying columns count:', columns.length);
            console.log('Underlying rows count:', rows.length);
            
            const metrics = [];
            
            // Process first few rows to extract ALL numeric metrics
            for (let i = 0; i < Math.min(rows.length, 10); i++) {
                const row = rows[i];
                
                columns.forEach(function(col, colIndex) {
                    if (row[colIndex]) {
                        let value = row[colIndex];
                        
                        // Extract from DataValue
                        if (typeof value === 'object' && value.value !== undefined) {
                            value = value.value;
                        }
                        
                        // Include ALL numeric values
                        if (typeof value === 'number' && !metrics.some(m => m.name === col)) {
                            console.log(`‚úÖ Found metric in underlying: ${col} = ${value}`);
                            metrics.push({
                                name: col,
                                value: value
                            });
                        }
                    }
                });
            }
            
            return {
                program: '11.0701 | Computer Science | Bachelor\'s',
                jobTarget: 'Software Developers',
                metrics: metrics,
                dataSource: 'Underlying Data',
                recordCount: Math.min(rows.length, 100)
            };
        }

        function callAPI(data) {
            // Build the final prompt
            let prompt;
            
            if (customPrompt) {
                // Use custom prompt and replace placeholders
                console.log('üîç Using custom prompt template');
                
                // Replace placeholders in the custom prompt
                prompt = customPrompt
                    .replace(/\{\{PROGRAM\}\}/g, data.program)
                    .replace(/\{\{JOB_TARGET\}\}/g, data.jobTarget)
                    .replace(/\{\{TIMESTAMP\}\}/g, data.timestamp)
                    .replace(/\{\{DATA_SOURCE\}\}/g, data.dataSource)
                    .replace(/\{\{METRICS\}\}/g, data.metrics.map(m => `‚Ä¢ ${m.name}: ${m.value}`).join('\n'));
                
            } else {
                // Fallback to built-in prompt
                console.log('üîç Using fallback built-in prompt');
                
                prompt = `Analyze this program performance data extracted at ${data.timestamp}:

PROGRAM: ${data.program}
JOB TARGET: ${data.jobTarget}
DATA SOURCE: ${data.dataSource}
EXTRACTION TIME: ${data.timestamp}

KEY METRICS:
${data.metrics.map(m => `‚Ä¢ ${m.name}: ${m.value}`).join('\n')}

Provide a concise analysis with:
1. Overall performance assessment
2. Key strengths and areas for improvement
3. Strategic recommendations

Focus on actionable insights for academic administrators. Start with the program name and current timestamp to confirm this is fresh data.`;
            }

            // ===== SEND TO API =====
            console.log('üöÄ Sending prompt to Claude API...');

            return fetch('https://uq-solutions.vercel.app/api/claude', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt: prompt })
            })
            .then(function(response) {
                console.log('API response status:', response.status);
                if (!response.ok) throw new Error('API error: ' + response.status);
                return response.json();
            })
            .then(function(result) {
                console.log('API result:', result);
                if (result && result.success) {
                    return result.content;
                } else {
                    throw new Error(result?.error || 'API returned error');
                }
            })
            .catch(function(error) {
                console.error('API error:', error);
                throw new Error('Claude API failed: ' + error.message);
            });
        }

        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }
    </script>
</body>
</html>
