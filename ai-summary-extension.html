<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>AI Program Summary</title>
    <style>
        body {
            font-family: 'Avenir', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 1px solid #e9ecef;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 2px solid #dee2e6;
        }
        
        .title {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
            margin: 0;
        }
        
        .refresh-btn {
            background: #03304d;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-family: 'Avenir', sans-serif;
            transition: all 0.3s ease;
        }
        
        .refresh-btn:hover {
            background: #024a73;
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(3, 48, 77, 0.4);
        }
        
        .loading {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 20px;
            background: #e3f2fd;
            border-radius: 8px;
            color: #1976d2;
            font-weight: 500;
            font-family: 'Avenir', sans-serif;
            border: 1px solid #bbdefb;
        }
        
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #e3f2fd;
            border-top: 2px solid #1976d2;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .summary-text {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 12px;
            padding: 24px;
            min-height: 200px;
            font-size: 16px;
            line-height: 1.6;
            color: #2c3e50;
            white-space: pre-wrap;
            font-family: 'Avenir', sans-serif;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
        }
        
        .error {
            background: #ffebee;
            color: #c62828;
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #ffcdd2;
            margin-top: 20px;
            font-family: 'Avenir', sans-serif;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">AI Program Summary</h1>
            <div>
                <button id="diagnosticsBtn" style="margin-right: 10px; padding: 8px 16px; background: #32a900; color: white; border: none; border-radius: 4px; cursor: pointer; font-family: 'Avenir', sans-serif; font-weight: 500;">
                    Run Diagnostics
                </button>
                <button class="refresh-btn" id="refreshBtn">
                    Generate Summary
                </button>
            </div>
        </div>
        
        <div id="loadingIndicator" class="loading" style="display: none;">
            <div class="spinner"></div>
            <span>Analyzing program data...</span>
        </div>
        
        <div class="summary-container">
            <div class="summary-text" id="summaryText">
                Click "Generate Summary" to analyze your program data and create an AI-powered summary.
            </div>
        </div>
        
        <div id="errorMessage" class="error" style="display: none;"></div>
    </div>

    <script>
        console.log('üöÄ AI Summary Extension v2025.01.25.2 loaded');
        
        // GitHub Pages URLs for Tableau API
        const GITHUB_API_URLS = [
            'https://lucas-wisnieski.github.io/UQ-Solutions/js/tableau.extensions.1.latest.js',
            'https://lucas-wisnieski.github.io/UQ-Solutions/js/tableau.extensions.1.latest.min.js'
        ];

        // Custom prompt URL
        const CUSTOM_PROMPT_URL = 'https://raw.githubusercontent.com/Lucas-Wisnieski/UQ-Solutions/main/prompts/ai-analysis-prompt.txt';

        // Global state
        let isProcessing = false;
        let customPrompt = null; // Cache for the custom prompt

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, setting up...');
            
            try {
                document.getElementById('diagnosticsBtn').addEventListener('click', runDiagnostics);
                document.getElementById('refreshBtn').addEventListener('click', generateSummary);
                console.log('‚úÖ Event listeners added');
                
                // Load custom prompt first, then Tableau API
                loadCustomPrompt();
            } catch (error) {
                console.error('Setup error:', error);
                showError('Extension setup failed: ' + error.message);
            }
        });

        function loadCustomPrompt() {
            console.log('üîç Loading custom prompt from GitHub...');
            
            fetch(CUSTOM_PROMPT_URL)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Prompt file not found: ' + response.status);
                    }
                    return response.text();
                })
                .then(function(promptText) {
                    customPrompt = promptText.trim();
                    console.log('‚úÖ Custom prompt loaded successfully');
                    console.log('üìÑ Prompt length:', customPrompt.length, 'characters');
                    
                    // Now load Tableau API
                    loadTableauAPI();
                })
                .catch(function(error) {
                    console.error('‚ùå Failed to load custom prompt:', error);
                    showError('Failed to load analysis prompt: ' + error.message + '\n\nPlease ensure the prompt file exists at:\n' + CUSTOM_PROMPT_URL);
                });
        }

        function loadTableauAPI() {
            console.log('üîç Loading Tableau API...');
            
            // Check if already available
            if (typeof tableau !== 'undefined' && tableau.extensions) {
                console.log('‚úÖ Tableau API already available');
                initializeExtension();
                return;
            }

            const urls = [
                ...GITHUB_API_URLS,
                'https://raw.githubusercontent.com/tableau/extensions-api/master/lib/tableau.extensions.1.latest.js'
            ];

            let currentIndex = 0;

            function tryLoad() {
                if (currentIndex >= urls.length) {
                    console.log('‚ùå All API loading attempts failed');
                    return;
                }

                const url = urls[currentIndex];
                console.log(`üîÑ Trying: ${url}`);

                const script = document.createElement('script');
                script.src = url;
                
                script.onload = function() {
                    console.log(`‚úÖ Loaded from: ${url}`);
                    if (typeof tableau !== 'undefined' && tableau.extensions) {
                        initializeExtension();
                    }
                };
                
                script.onerror = function() {
                    console.log(`‚ùå Failed: ${url}`);
                    currentIndex++;
                    setTimeout(tryLoad, 100);
                };
                
                document.head.appendChild(script);
            }

            tryLoad();
        }

        function initializeExtension() {
            if (tableau && tableau.extensions) {
                tableau.extensions.initializeAsync()
                    .then(function() {
                        console.log('üéâ Extension initialized!');
                    })
                    .catch(function(error) {
                        console.error('‚ùå Init failed:', error);
                    });
            }
        }

        function runDiagnostics() {
            if (isProcessing) return;
            
            console.log('=== DIAGNOSTICS ===');
            
            let report = 'üîç DIAGNOSTIC REPORT\n\n';
            
            // Check API
            if (typeof tableau !== 'undefined' && tableau.extensions) {
                report += 'üìä TABLEAU API: ‚úÖ Available\n';
                
                try {
                    const worksheets = tableau.extensions.dashboardContent.dashboard.worksheets;
                    report += `üìã WORKSHEETS: ${worksheets.length} found\n`;
                    
                    worksheets.forEach((ws, i) => {
                        report += `  ${i + 1}. "${ws.name}"\n`;
                    });
                    
                    const target = worksheets.find(ws => 
                        ws.name.toLowerCase().includes('claude') || 
                        ws.name.toLowerCase().includes('metrics')
                    );
                    
                    if (target) {
                        report += `\nüéØ TARGET: "${target.name}" ‚úÖ\n`;
                    } else {
                        report += '\n‚ö†Ô∏è No target worksheet found\n';
                    }
                    
                } catch (error) {
                    report += `üìä API ERROR: ${error.message}\n`;
                }
            } else {
                report += 'üìä TABLEAU API: ‚ùå Not Available\n';
            }
            
            report += '\nüîß PROXY: https://uq-solutions.vercel.app/api/claude ‚úÖ\n';
            report += `\nüìÑ CUSTOM PROMPT: ${customPrompt ? '‚úÖ Loaded (' + customPrompt.length + ' chars)' : '‚ùå Not loaded'}\n`;
            report += '\nüéØ STATUS: Ready for testing';
            
            document.getElementById('summaryText').textContent = report;
        }

        function generateSummary() {
            if (isProcessing) {
                console.log('Already processing...');
                return;
            }
            
            // Check if custom prompt is loaded
            if (!customPrompt) {
                showError('Custom prompt not loaded. Please refresh the page and try again.');
                return;
            }
            
            isProcessing = true;
            console.log('üöÄ Starting summary generation with custom prompt...');
            
            document.getElementById('loadingIndicator').style.display = 'block';
            hideError();
            
            // Simple timeout
            setTimeout(function() {
                if (isProcessing) {
                    isProcessing = false;
                    document.getElementById('loadingIndicator').style.display = 'none';
                    showError('Process timed out after 45 seconds');
                }
            }, 45000);
            
            extractData()
                .then(function(data) {
                    console.log('‚úÖ Data extracted:', data);
                    
                    // Only proceed if we have meaningful metrics
                    if (!data.metrics || data.metrics.length === 0) {
                        throw new Error('No meaningful metrics extracted from the data');
                    }
                    
                    return callAPI(data);
                })
                .then(function(summary) {
                    document.getElementById('summaryText').innerHTML = summary;
                })
                .catch(function(error) {
                    console.error('‚ùå Failed:', error);
                    showError('Failed: ' + error.message);
                })
                .finally(function() {
                    isProcessing = false;
                    document.getElementById('loadingIndicator').style.display = 'none';
                });
        }

        function extractData() {
            return new Promise(function(resolve, reject) {
                // Check API availability
                if (typeof tableau === 'undefined' || !tableau.extensions) {
                    reject(new Error('Tableau API not available'));
                    return;
                }

                try {
                    const worksheets = tableau.extensions.dashboardContent.dashboard.worksheets;
                    console.log(`Found ${worksheets.length} worksheets`);
                    
                    // Find target worksheet
                    let target = worksheets.find(ws => 
                        ws.name.toLowerCase().includes('claude') || 
                        ws.name.toLowerCase().includes('metrics')
                    );
                    
                    if (!target && worksheets.length > 0) {
                        target = worksheets[0];
                    }
                    
                    if (!target) {
                        reject(new Error('No worksheets found'));
                        return;
                    }
                    
                    console.log(`Using worksheet: "${target.name}"`);
                    
                    // Force refresh the worksheet data before extracting
                    console.log('üîÑ Refreshing worksheet data...');
                    
                    // Try to refresh the data first, then extract
                    Promise.resolve()
                        .then(function() {
                            // Try to refresh if the method exists
                            if (target.refreshDataAsync) {
                                console.log('Attempting data refresh...');
                                return target.refreshDataAsync();
                            } else {
                                console.log('Refresh not available, proceeding with current data...');
                                return Promise.resolve();
                            }
                        })
                        .catch(function(refreshError) {
                            console.log('Refresh failed, proceeding with current data:', refreshError.message);
                            return Promise.resolve(); // Continue even if refresh fails
                        })
                        .then(function() {
                            // Small delay to ensure data is updated
                            return new Promise(resolve => setTimeout(resolve, 500));
                        })
                        .then(function() {
                            // Now try to get the updated summary data
                            return target.getSummaryDataAsync();
                        })
                        .then(function(summaryData) {
                            console.log(`Got ${summaryData.data.length} summary rows`);
                            
                            if (summaryData.data.length > 0) {
                                const data = processSummaryData(summaryData);
                                if (data.metrics.length >= 3) {
                                    console.log('‚úÖ Using summary data with', data.metrics.length, 'metrics');
                                    resolve(data);
                                    return;
                                } else {
                                    console.log(`‚ö†Ô∏è Summary data has only ${data.metrics.length} metrics, trying underlying data...`);
                                }
                            }
                            
                            // Fallback to underlying data only if summary failed
                            console.log('Summary data insufficient, trying underlying data...');
                            return target.getUnderlyingDataAsync();
                        })
                        .then(function(underlyingData) {
                            if (!underlyingData) {
                                reject(new Error('No underlying data available'));
                                return;
                            }
                            
                            console.log(`Got ${underlyingData.data.length} underlying rows`);
                            const data = processUnderlyingData(underlyingData);
                            
                            if (data.metrics.length === 0) {
                                reject(new Error('No meaningful metrics found in underlying data'));
                                return;
                            }
                            
                            console.log('‚úÖ Using underlying data with', data.metrics.length, 'metrics');
                            resolve(data);
                        })
                        .catch(function(error) {
                            console.error('Data extraction error:', error);
                            reject(new Error('Data extraction failed: ' + error.message));
                        });
                    
                } catch (error) {
                    reject(error);
                }
            });
        }

        function processSummaryData(dataTable) {
            const columns = dataTable.columns.map(col => col.fieldName);
            const rows = dataTable.data;
            
            console.log('Summary columns:', columns);
            console.log('Summary rows:', rows.length);
            
            // Debug: Show first few rows
            console.log('First 3 rows:', rows.slice(0, 3));
            
            const metrics = [];
            
            // Look for the "Measure Values" column which contains the actual scores
            const measureValuesIndex = columns.findIndex(col => 
                col.toLowerCase().includes('measure values') || 
                col.toLowerCase().includes('values')
            );
            
            const measureNamesIndex = columns.findIndex(col => 
                col.toLowerCase().includes('measure names') || 
                col.toLowerCase().includes('names')
            );
            
            console.log('Measure Values column index:', measureValuesIndex);
            console.log('Measure Names column index:', measureNamesIndex);
            
            if (measureValuesIndex >= 0 && measureNamesIndex >= 0) {
                console.log('‚úÖ Found Measure Names/Values columns - extracting metrics...');
                
                // Process each row to extract measure name/value pairs
                rows.forEach(function(row, rowIndex) {
                    if (rowIndex < 20) { // Process first 20 rows
                        let measureName = null;
                        let measureValue = null;
                        
                        // Extract measure name
                        if (row[measureNamesIndex]) {
                            const nameCell = row[measureNamesIndex];
                            measureName = (typeof nameCell === 'object' && nameCell.value !== undefined) 
                                ? nameCell.value : nameCell;
                        }
                        
                        // Extract measure value
                        if (row[measureValuesIndex]) {
                            const valueCell = row[measureValuesIndex];
                            measureValue = (typeof valueCell === 'object' && valueCell.value !== undefined) 
                                ? valueCell.value : valueCell;
                        }
                        
                        // If we have both name and numeric value, add it
                        if (measureName && typeof measureValue === 'number') {
                            // Clean up the measure name for better readability
                            let cleanName = measureName;
                            
                            // Remove Tableau's internal field references
                            if (typeof cleanName === 'string') {
                                // Extract the actual measure name from Tableau's internal format
                                const nameMatch = cleanName.match(/\[usr:([^\]]+)\]/);
                                if (nameMatch) {
                                    cleanName = nameMatch[1]
                                        .replace(/_\d+:/g, '') // Remove ID numbers and colons
                                        .replace(/qk\]?$/, '') // Remove 'qk' suffix
                                        .replace(/\s+\(copy[^)]*\)/gi, '') // Remove "(copy)" variations
                                        .replace(/[_]/g, ' ') // Replace underscores with spaces
                                        .trim();
                                }
                                
                                // If no match, try to clean the original name
                                if (!nameMatch) {
                                    cleanName = cleanName
                                        .replace(/\[federated[^\]]+\]\./g, '') // Remove federated prefix
                                        .replace(/\[usr:/g, '') // Remove usr: prefix
                                        .replace(/\]/g, '') // Remove brackets
                                        .replace(/_\d+:/g, '') // Remove ID numbers
                                        .replace(/qk$/, '') // Remove qk suffix
                                        .replace(/\s+\(copy[^)]*\)/gi, '') // Remove copy variations
                                        .replace(/[_]/g, ' ') // Replace underscores with spaces
                                        .trim();
                                }
                            }
                            
                            console.log(`Found metric from summary: ${cleanName} = ${measureValue}`);
                            
                            metrics.push({
                                name: cleanName,
                                value: measureValue,
                                originalName: measureName // Keep original for debugging
                            });
                        }
                    }
                });
            } else {
                console.log('‚ö†Ô∏è Measure Names/Values columns not found, trying alternative approach...');
                
                // Fallback: look for numeric columns directly
                rows.forEach(function(row, rowIndex) {
                    if (rowIndex < 10) {
                        columns.forEach(function(col, colIndex) {
                            if (row[colIndex]) {
                                let value = row[colIndex];
                                
                                // Extract value from DataValue objects
                                if (typeof value === 'object' && value.value !== undefined) {
                                    value = value.value;
                                }
                                
                                // Check if it's a number and a relevant metric
                                if (typeof value === 'number') {
                                    const isRelevant = col.toLowerCase().includes('score') ||
                                                     col.toLowerCase().includes('growth') ||
                                                     col.toLowerCase().includes('%') ||
                                                     col.toLowerCase().includes('total');
                                    
                                    if (isRelevant && !metrics.some(m => m.name === col)) {
                                        console.log(`Found direct metric: ${col} = ${value}`);
                                        metrics.push({
                                            name: col,
                                            value: value
                                        });
                                    }
                                }
                            }
                        });
                    }
                });
            }
            
            console.log(`Summary data processing complete: ${metrics.length} metrics found`);
            
            // Extract current program and job from the first row of data
            let currentProgram = '11.0701 | Computer Science | Bachelor\'s'; // default
            let currentJob = 'Software Developers'; // default
            
            if (rows.length > 0) {
                // Check first row for actual current selections
                const firstRow = rows[0];
                
                // Extract CIP Code & Award Level
                if (firstRow[0]) {
                    const cipValue = (typeof firstRow[0] === 'object' && firstRow[0].value !== undefined) 
                        ? firstRow[0].value : firstRow[0];
                    if (cipValue && cipValue !== '%null%') {
                        currentProgram = cipValue;
                        console.log('üìä Current program from data:', currentProgram);
                    }
                }
                
                // Extract UQ Job
                if (firstRow[1]) {
                    const jobValue = (typeof firstRow[1] === 'object' && firstRow[1].value !== undefined) 
                        ? firstRow[1].value : firstRow[1];
                    if (jobValue && jobValue !== '%null%') {
                        currentJob = jobValue;
                        console.log('üéØ Current job from data:', currentJob);
                    }
                }
            }
            
            return {
                program: currentProgram,
                jobTarget: currentJob,
                metrics: metrics,
                dataSource: 'Summary Data (Tableau View)',
                recordCount: rows.length,
                timestamp: new Date().toLocaleString()
            };
        }

        function processUnderlyingData(dataTable) {
            const columns = dataTable.columns.map(col => col.fieldName);
            const rows = dataTable.data;
            
            console.log('Underlying columns count:', columns.length);
            console.log('Underlying rows count:', rows.length);
            
            const metrics = [];
            const targetMetrics = [
                'Market Growth Score', 'Schools Like Us Score', 'Earning Outcomes Score',
                'Workforce Demand Score', 'Total Score', 'Opportunity Size Score'
            ];
            
            // Process only first few rows for speed
            for (let i = 0; i < Math.min(rows.length, 5); i++) {
                const row = rows[i];
                
                columns.forEach(function(col, colIndex) {
                    if (row[colIndex]) {
                        let value = row[colIndex];
                        
                        // Extract from DataValue
                        if (typeof value === 'object' && value.value !== undefined) {
                            value = value.value;
                        }
                        
                        // Look for target metrics
                        if (typeof value === 'number') {
                            const isTarget = targetMetrics.some(tm => 
                                col.toLowerCase().includes(tm.toLowerCase())
                            );
                            
                            if (isTarget && !metrics.some(m => m.name === col)) {
                                metrics.push({
                                    name: col,
                                    value: value
                                });
                            }
                        }
                    }
                });
                
                // Stop if we have enough metrics
                if (metrics.length >= 8) break;
            }
            
            return {
                program: '11.0701 | Computer Science | Bachelor\'s',
                jobTarget: 'Software Developers',
                metrics: metrics,
                dataSource: 'Underlying Data',
                recordCount: Math.min(rows.length, 100)
            };
        }

        function callAPI(data) {
            const prompt = `Analyze this program performance data extracted at ${data.timestamp}:

PROGRAM: ${data.program}
JOB TARGET: ${data.jobTarget}
DATA SOURCE: ${data.dataSource}
EXTRACTION TIME: ${data.timestamp}

KEY METRICS:
${data.metrics.map(m => `‚Ä¢ ${m.name}: ${m.value}`).join('\n')}

Provide a concise analysis with:
1. Overall performance assessment
2. Key strengths and areas for improvement
3. Strategic recommendations

Focus on actionable insights for academic administrators. Start with the program name and current timestamp to confirm this is fresh data.`;

            return fetch('https://uq-solutions.vercel.app/api/claude', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt: prompt })
            })
            .then(function(response) {
                console.log('API response status:', response.status);
                if (!response.ok) throw new Error('API error: ' + response.status);
                return response.json();
            })
            .then(function(result) {
                console.log('API result:', result);
                if (result && result.success) {
                    return result.content;
                } else {
                    throw new Error(result?.error || 'API returned error');
                }
            })
            .catch(function(error) {
                console.error('API error:', error);
                throw new Error('Claude API failed: ' + error.message);
            });
        }

        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }
    </script>
</body>
</html
